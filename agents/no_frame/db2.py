# generated by ai

# db_agent.py
import sqlite3
import pandas as pd
from typing import List, Dict, Optional
from collections import deque
import numpy as np
import hashlib

class QueryContext:
    """上下文感知模块"""
    def __init__(self, max_history=100):
        self.query_history = deque(maxlen=max_history)  # 存储历史查询特征
        self.user_profiles = {}  # 用户ID -> 查询偏好
        self.data_statistics = {}  # 表名 -> 字段分布统计
        
    def update_context(self, query_info: Dict):
        """更新上下文信息"""
        # 记录查询元数据
        self.query_history.append({
            'table': query_info['table'],
            'keywords': query_info['keywords'],
            'exec_time': query_info['exec_time'],
            'result_size': query_info['result_size']
        })
        
        # 更新用户画像
        user_id = query_info.get('user_id', 'default')
        if user_id not in self.user_profiles:
            self.user_profiles[user_id] = {
                'preferred_tables': {},
                'common_filters': {}
            }
        # 记录表使用频率
        self.user_profiles[user_id]['preferred_tables'][query_info['table']] = \
            self.user_profiles[user_id]['preferred_tables'].get(query_info['table'], 0) + 1

class QueryStrategist:
    """动态策略选择引擎"""
    STRATEGIES = {
        'full_scan': {'weight': 0.1},
        'index_search': {'weight': 0.6},
        'approximate': {'weight': 0.3}
    }
    
    def __init__(self, context: QueryContext):
        self.context = context
        self._init_strategy_performance()
        
    def _init_strategy_performance(self):
        """初始化策略性能基准"""
        self.strategy_scores = {
            'full_scan': {'success': 0, 'fail': 0},
            'index_search': {'success': 0, 'fail': 0},
            'approximate': {'success': 0, 'fail': 0}
        }
    
    def select_strategy(self, table: str, keywords: List[str]) -> str:
        """基于上下文选择最优策略"""
        # 获取表统计信息
        stats = self.context.data_statistics.get(table, {})
        
        # 策略选择逻辑
        if stats.get('row_count', 0) < 1000:
            return 'full_scan'
            
        if any(kw in stats.get('indexed_columns', []) for kw in keywords):
            return 'index_search'
            
        # 使用强化学习模型选择（示例使用epsilon-greedy）
        return np.random.choice(
            list(self.STRATEGIES.keys()), 
            p=[self.STRATEGIES[s]['weight'] for s in self.STRATEGIES]
        )

    def update_strategy_performance(self, strategy: str, success: bool):
        """更新策略效果"""
        if success:
            self.strategy_scores[strategy]['success'] += 1
        else:
            self.strategy_scores[strategy]['fail'] += 1
        # 动态调整策略权重
        total = self.strategy_scores[strategy]['success'] + self.strategy_scores[strategy]['fail']
        self.STRATEGIES[strategy]['weight'] = self.strategy_scores[strategy]['success'] / total if total >0 else 0.5

class IntelligentQueryAgent:
    """自主决策的查询智能体"""
    def __init__(self, db_path: str):
        self.conn = sqlite3.connect(db_path)
        self.cur = self.conn.cursor()
        self.context = QueryContext()
        self.strategist = QueryStrategist(self.context)
        
        # 初始化元数据
        self._load_metadata()
        
    def _load_metadata(self):
        """加载数据库元数据"""
        tables = self.cur.execute("SELECT name FROM sqlite_master WHERE type='table'").fetchall()
        for (table,) in tables:
            # 获取字段信息
            cols = self.cur.execute(f"PRAGMA table_info({table})").fetchall()
            self.context.data_statistics[table] = {
                'columns': [col[1] for col in cols],
                'indexed_columns': self._get_indexed_columns(table),
                'row_count': self._get_table_row_count(table)
            }
    
    def _get_indexed_columns(self, table: str) -> List[str]:
        """获取已索引字段"""
        indexes = self.cur.execute(f"PRAGMA index_list({table})").fetchall()
        indexed_cols = []
        for index in indexes:
            cols = self.cur.execute(f"PRAGMA index_info({index[1]})").fetchall()
            indexed_cols.extend([col[2] for col in cols])
        return list(set(indexed_cols))
    
    def _get_table_row_count(self, table: str) -> int:
        """获取表行数估算"""
        try:
            return self.cur.execute(f"SELECT COUNT(*) FROM {table}").fetchone()[0]
        except:
            return 0
            
    def generate_query(self, table: str, keywords: List[str], user_context: Dict = None) -> Optional[str]:
        """自主生成优化查询"""
        # 上下文感知
        strategy = self.strategist.select_strategy(table, keywords)
        
        # 根据策略生成查询
        if strategy == 'full_scan':
            query = self._full_scan_query(table, keywords)
        elif strategy == 'index_search':
            query = self._index_based_query(table, keywords)
        elif strategy == 'approximate':
            query = self._approximate_query(table, keywords)
        else:
            return None
            
        return query
    
    def _full_scan_query(self, table: str, keywords: List[str]) -> str:
        """全表扫描策略"""
        where_clause = " OR ".join([f"{col} LIKE ?" for col in self.context.data_statistics[table]['columns']])
        return f"SELECT * FROM {table} WHERE {where_clause} LIMIT 500", [f"%{kw}%" for kw in keywords for _ in self.context.data_statistics[table]['columns']]
    
    def _index_based_query(self, table: str, keywords: List[str]) -> str:
        """索引优化策略"""
        indexed_cols = self.context.data_statistics[table]['indexed_columns']
        conditions = []
        params = []
        for col in indexed_cols:
            for kw in keywords:
                conditions.append(f"{col} LIKE ?")
                params.append(f"%{kw}%")
        return f"SELECT * FROM {table} WHERE {' OR '.join(conditions)} LIMIT 100", params
    
    def _approximate_query(self, table: str, keywords: List[str]) -> str:
        """近似查询策略"""
        # 使用特征哈希加速
        hash_dim = 64
        hash_values = [int(hashlib.md5(kw.encode()).hexdigest(), 16) % hash_dim for kw in keywords]
        return f"""
        SELECT *, 
               SUM({' + '.join([f'(feature_hash & {1 << v})' for v in hash_values])}) AS relevance 
        FROM {table}
        ORDER BY relevance DESC
        LIMIT 50
        """, []
    
    def execute_query(self, query: str, params: List[str]) -> Dict:
        """执行查询并收集上下文"""
        try:
            start_time = time.time()
            self.cur.execute(query, params)
            results = self.cur.fetchall()
            exec_time = time.time() - start_time
            
            # 更新上下文
            self.context.update_context({
                'table': query.split()[2],  # 简单解析表名
                'keywords': params,
                'exec_time': exec_time,
                'result_size': len(results)
            })
            
            return {
                'status': 'success',
                'data': results,
                'metrics': {
                    'execution_time': exec_time,
                    'result_count': len(results)
                }
            }
        except Exception as e:
            return {
                'status': 'error',
                'message': str(e)
            }
    
    def close(self):
        """关闭数据库连接"""
        self.conn.close()

# 使用示例
if __name__ == "__main__":
    agent = IntelligentQueryAgent("test.db")
    
    # 模拟用户请求
    test_case = {
        'table': 'air_quality',
        'keywords': ['北京', 'PM2.5'],
        'user_id': 'user_001'
    }
    
    # 生成查询
    query, params = agent.generate_query(**test_case)
    print(f"Generated Query:\n{query}\nParameters: {params}")
    
    # 执行查询
    result = agent.execute_query(query, params)
    print(f"Execution Result: {result['status']}")
    print(f"Metrics: {result['metrics']}")
    
    agent.close()
